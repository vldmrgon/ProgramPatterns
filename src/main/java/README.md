

### Создающие паттерны

1. **Абстрактная фабрика (Abstract Factory)**: Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов без указания их конкретных классов.

2. **Строитель (Builder)**: Отделяет процесс конструирования сложного объекта от его представления, позволяя использовать один и тот же процесс конструирования для создания разных представлений объекта.

3. **Фабричный метод (Factory Method)**: Определяет интерфейс для создания объектов, но позволяет подклассам решать, какой класс конкретных объектов создавать.

4. **Прототип (Prototype)**: Позволяет создавать новые объекты путем копирования существующих объектов-прототипов, избегая непосредственного создания объектов с нуля.

5. **Одиночка (Singleton)**: Гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.

6. **Пул объектов (Object Pool)**: Предварительно создает и поддерживает пул объектов для повторного использования. Это позволяет управлять жизненным циклом объектов и избегать накладных расходов на создание и уничтожение объектов.

7. **Мультитон (Multiton)**: Позволяет иметь несколько именованных экземпляров одного и того же класса. Каждый экземпляр идентифицируется уникальным ключом и представляет собой глобальную точку доступа к объекту.


### Структурные паттерны

1. **Адаптер (Adapter)**: Преобразует интерфейс одного класса в другой, чтобы они могли работать вместе, когда у них несовместимые интерфейсы.

2. **Мост (Bridge)**: Отделяет абстракцию от ее реализации, позволяя им изменяться независимо друг от друга. Это особенно полезно, когда классы имеют несколько вариаций в абстракции и реализации.

3. **Компоновщик (Composite)**: Объединяет объекты в древовидную структуру для представления иерархии "часть-целое". Позволяет работать с отдельными объектами и группами объектов одинаковым образом.

4. **Декоратор (Decorator)**: Динамически добавляет новую функциональность объектам, оборачивая их в декораторы. Это позволяет расширять функциональность объектов без изменения их базовой структуры.

5. **Фасад (Facade)**: Предоставляет унифицированный интерфейс для набора интерфейсов в подсистеме. Упрощает работу с подсистемой, предоставляя удобный интерфейс высокого уровня.

6. **Приспособленец (Flyweight)**: Разделяет объекты на интрузивное (разделяемое) состояние и экструзивное (уникальное) состояние для экономии памяти. Позволяет эффективно поддерживать большое количество мелких объектов.

7. **Заместитель (Proxy)**: Представляет суррогат другого объекта, контролирует доступ к нему и предоставляет дополнительную функциональность. Позволяет добавить дополнительное поведение перед, во время или после выполнения операций над объектом.


### Поведенческие паттерны

1. **Цепочка обязанностей (Chain of Responsibility)**: Позволяет передавать запросы по цепочке потенциальных обработчиков, пока один из них не обработает запрос.

2. **Команда (Command)**: Инкапсулирует запрос в виде объекта, позволяя параметризовать клиентов с различными запросами, организовывать очередь или регистрировать запросы и поддерживать отмену операций.

3. **Итератор (Iterator)**: Предоставляет способ доступа к элементам коллекции последовательно, без раскрытия внутренней структуры коллекции.

4. **Посредник (Mediator)**: Определяет объект, который инкапсулирует взаимодействие между набором объектов, позволяя им взаимодействовать друг с другом без явных ссылок.

5. **Снимок (Memento)**: Фиксирует внутреннее состояние объекта так, чтобы позднее можно было восстановить его в этом состоянии.

6. **Наблюдатель (Observer)**: Определяет зависимость "один-ко-многим" между объектами таким образом, чтобы при изменении состояния одного объекта все зависимые от него объекты были уведомлены и автоматически обновлены.

7. **Состояние (State)**: Позволяет объекту изменять свое поведение в зависимости от его внутреннего состояния, создавая различные классы состояний, которые могут быть легко переключаемыми.

8. **Стратегия (Strategy)**: Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Позволяет выбирать алгоритм во время выполнения.

9. **Шаблонный метод (Template Method)**: Определяет скелет алгоритма в родительском классе, позволяя подклассам переопределить некоторые шаги этого алгоритма без изменения его общей структуры.

10. **Посетитель (Visitor)**: Позволяет добавлять новые операции к объектам без изменения их классов, разделяя алгоритмы от структуры объектов.
